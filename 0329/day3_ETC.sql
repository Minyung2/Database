-- INDEX
SELECT * FROM SCOTT.emp;
CREATE INDEX emp_index ON SCOTT.emp(empno,ename);
DROP INDEX emp_index;

-- DICTIONARY
SELECT * FROM DICT;
SELECT * FROM DICTIONARY ;

/**
 * USER_?? 사용자 관련 객체 정보
 * ALL_?? 사용자 사용 가능한 객체 정보
 * DBA_?? DB관련 정보(SYSTEM SYS)
 * V$_?? VIEW 관련
 * */

SELECT * FROM USER_TABLES;
SELECT * FROM ALL_TABLES WHERE OWNER='SCOTT';
SELECT * FROM DBA_TABLES;
SELECT * FROM DBA_USERS;
SELECT * FROM USER_INDEXES;
SELECT * FROM SCOTT.EMP;
SELECT * FROM USER_IND_COLUMNS ;
SELECT * FROM OBJ;

-- VIEW
DROP VIEW VW_EMP2;
CREATE VIEW VW_EMP2
AS (SELECT E.*, D.DNAME, D.LOC
FROM SCOTT.EMP E, SCOTT.DEPT D WHERE E.DEPTNO=D.DEPTNO);

COMMIT;
GRANT CREATE VIEW TO SCOTT;
SELECT * FROM VW_EMP2;
DROP VIEW VW_EMP2;
-- SEQUNECE
/*
	CREATE SEQUENCE (시퀀스명) 
   	CREATE SEQUENCE 시퀀스명
   	INCREMENT BY (숫자) 증가량
   	START WITH (숫자) 시작 값
   	(NO)MINVALUE (숫자)  최소숫자 설정 여부
   	(NO)MAXVALUE (숫자) 최대 숫자 설정 여부
   	(NO)CYCLE 최댓값 도달 시 시작 숫자부터 다시 시작 여부
   	(NO)CACHE 캐시를 사용할지 여부
   	캐시를 사용하여 미리 값을 할당해 놓아서 속도가 빠르며, 동시 사용자가 많을 경우 유리
   	(NO)ORDER 요청 순서대로 값 생성 여부
 */

CREATE SEQUENCE EX_SEQ
INCREMENT BY 1
START WITH 1
MINVALUE 1
MAXVALUE 1000
NOCYCLE
NOCACHE;
DROP TABLE SEQTABL ;
CREATE TABLE SEQTABLE(
	SEQNUM NUMBER(4), 
	TESTTXT VARCHAR2(10)
);
COMMIT;
SELECT * FROM SEQTABLE;
INSERT INTO SEQTABLE VALUES(EX_SEQ.NEXTVAL , 'TEST');
SELECT EX_SEQ.CURRVAL FROM DUAL;
SELECT EX_SEQ.NEXTVAL FROM DUAL;
ALTER SEQUENCE EX_SEQ INCREMENT BY -2;
ALTER SEQUENCE EX_SEQ INCREMENT BY 1;
DROP SEQUENCE EX_SEQ;

-- 줄번호

SELECT ROWNUM,A.*
FROM(
	SELECT E.*
	FROM EMP E
	ORDER BY E.ENAME
)A
ORDER BY A.JOB;

SELECT ROW_NUMBER() OVER(ORDER BY E.JOB,E.ENAME) 
ROW_NUM,E.* 
FROM EMP E ORDER BY 
E.JOB,E.ENAME;

-- OVER
SELECT JOB,SUM(SAL) FROM EMP WHERE JOB IN('MANAGER','SALESMAN') GROUP BY JOB ORDER BY JOB;
-- 위를 PARTITION으로 
SELECT EMPNO, ENAME,DEPTNO,JOB,SUM(SAL) OVER(PARTITION BY JOB) FROM EMP WHERE JOB IN('MANAGER','SALESMAN');

SELECT EMPNO, ENAME, JOB ,SAL, RANK() OVER(ORDER BY SAL DESC) AS 등수, DENSE_RANK() OVER(ORDER BY SAL DESC) AS 등수2
FROM EMP e WHERE SAL IS NOT NULL ORDER BY JOB;


--  SYNONYM 동의어
--  CREATE PUBLIC SYNONYM [NAME]
--  FOR [TARGET]

GRANT CREATE SYNONYM TO SCOTT;
CREATE SYNONYM DE FOR DEPT;
SELECT * FROM DE;
DROP SYNONYM DE;


-- Q1
CREATE TABLE EMPIDX AS SELECT * FROM EMP;
SELECT * FROM EMPIDX;
-- EMPIDX 테이블의 EMPNO 값을 기준으로 한 인덱스 IDX_EMPIDX_EMPNO 생성
CREATE INDEX IDX_EMPIDX_EMPNO ON EMPIDX (EMPNO);
SELECT * FROM USER_INDEXES WHERE INDEX_NAME='IDX_EMPIDX_EMPNO';

-- Q2 급여가 1500을 넘는 사람의 사번 이름 직급 급여 를 담은 뷰 EMPIDX_OVER15를 작성

CREATE VIEW EMPIDX_OVER15
AS (SELECT E.EMPNO ,E.ENAME, E.JOB , E.SAL FROM EMP E WHERE SAL>1500);

SELECT * FROM EMPIDX_OVER15;

-- Q3

CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
-- SEQ_DEPTSEQ 시퀀스를 생성 (1에서 99까지 1씩 증가 순환없음 캐쉬 안씀)
--	CREATE SEQUENCE (시퀀스명) 
--   	CREATE SEQUENCE 시퀀스명
--   	INCREMENT BY (숫자) 증가량
--   	START WITH (숫자) 시작 값
--   	(NO)MINVALUE (숫자)  최소숫자 설정 여부
--   	(NO)MAXVALUE (숫자) 최대 숫자 설정 여부
--   	(NO)CYCLE 최댓값 도달 시 시작 숫자부터 다시 시작 여부
--   	(NO)CACHE 캐시를 사용할지 여부
--   	캐시를 사용하여 미리 값을 할당해 놓아서 속도가 빠르며, 동시 사용자가 많을 경우 유리
--   	(NO)ORDER 요청 순서대로 값 생성 여부
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 1
START WITH 1
MAXVALUE 99
NOCYCLE
NOCACHE;


-- SEQ_DEPTSEQ 삭제
DROP SEQUENCE SEQ_DEPTSEQ;
-- SEQ_DEPTSEQ 시퀀스를 생성 (10에서 100까지 60부터 10씩 증가 순환없음 캐쉬 안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT (CASE WHEN SEQ.DEPTSEQ_CURRVAL = 60 THEN 10 ELSE 1 END) 
START WITH 10
MAXVALUE 100
NOCYCLE
NOCACHE;


CREATE SEQUENCE SEQ_DEPTSEQ
INCREMENT BY 10
START WITH 60
MINVALUE 10
MAXVALUE 100
NOCYCLE
NOCACHE;

COMMIT;
SELECT *
  FROM all_sequences
 WHERE sequence_name = 'SEQ_DEPTSEQ';


SELECT SEQ_DEPTSEQ.CURRVAL FROM DUAL;
SELECT SEQ_DEPTSEQ.NEXTVAL FROM DUAL;

-- UNION
SELECT * FROM EMP WHERE DEPTNO=10 UNION SELECT * FROM EMP WHERE DEPTNO =20;
--SELECT * FROM DEPT;

/*
START WITH [CONDITION]
CONNECT BY PRIOR [CONDITION]
*/
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, B.EMPNO, B.ENAME, B.JOB
FROM EMP A, EMP B
WHERE A.MGR=B.EMPNO ;

SELECT LEVEL,EMPNO,ENAME,MGR,JOB
FROM EMP
START WITH JOB='PRESIDENT'
CONNECT BY PRIOR EMPNO=MGR AND LEVEL<=2;

-- 숫자 찍기
SELECT * FROM(
	SELECT 1 AS NUM FROM DUAL UNION ALL
	SELECT 2 FROM DUAL UNION ALL
	SELECT 3 FROM DUAL UNION ALL
	SELECT 4 FROM DUAL UNION ALL
	SELECT 5 FROM DUAL UNION ALL
	SELECT 6 FROM DUAL
);
	
SELECT * FROM EMP WHERE LOWER(ENAME)='james';
SELECT ENAME,LENGTH(ENAME), SAL, LENGTH(SAL), LENGTH('한글'),LENGTHB('한글')
FROM EMP;

SELECT JOB,SUBSTR(JOB,1,2),SUBSTR(JOB,3,2),SUBSTR(JOB,5),
SUBSTR(JOB,-LENGTH(JOB)),SUBSTR(JOB,-LENGTH(JOB),2),SUBSTR(JOB,-3) 
FROM EMP;